#!/bin/bash
# Configure
root="$( cd "$( dirname "${BASH_SOURCE[0]}" )/../.." >/dev/null 2>&1 && pwd )"
GRID=${root}/dependencies/Grid/build
if [ ! -d ${GRID} ];
then
    GRID=${root}/../Grid/build
fi
if [ ! -d ${GRID} ];
then
    echo "Could not detect Grid location"
    exit 2
fi
NPARALLEL=32

# Start
N=0

mkdir -p build logs

echo "================================================================================"
echo "  Compiling CGPT against Grid in ${GRID}"
echo "================================================================================"

NUMPY_INCLUDE=$(python3 -c "import numpy; print(numpy.get_include())")
CXX=$(grep "GRID_CXX " ${GRID}/Makefile | sed "s/^[^=]*=//")
CXXFLAGS="$(grep "GRID_CXXFLAGS " ${GRID}/Makefile | sed "s/^[^=]*=//") $(grep "AM_CFLAGS " ${GRID}/Makefile | sed "s/^[^=]*=//") -I${GRID} -I${GRID}/Grid -I${NUMPY_INCLUDE} $(python3-config --includes)"
LDFLAGS="$(grep "GRID_LDFLAGS " ${GRID}/Makefile | sed "s/^[^=]*=//") $(grep "AM_LDFLAGS " ${GRID}/Makefile | sed "s/^[^=]*=//")"
LIBS=$(grep "GRID_LIBS " ${GRID}/Makefile | sed "s/^[^=]*=//")

echo "CXX = $CXX"
echo "CXXFLAGS = $CXXFLAGS"
echo "LDFLAGS = $LDFLAGS"
echo "LIBS = $LIBS"

echo "================================================================================"

# Automatically generate list of exported functions
(
    echo "// This file is automatically generated, do not modify!" 
    sed -n 's/EXPORT(\([^,{]*\),{/EXPORT_FUNCTION(\1)/p' lib/*.cc 
) > lib/exports.h
echo "Found $(grep -c EXPORT lib/exports.h) exported functions"

# if exports changed, re-compile lib.o
if [ -f lib/exports.h~ ];
then
    diff lib/exports.h lib/exports.h~ > /dev/null
    if [[ "$?" != "0" ]];
    then
	rm -f build/lib.o
    fi
fi
cp lib/exports.h lib/exports.h~

# Automatically generate interface for exported fermion operators
(
    echo "// This file is automatically generated, do not modify!" 
    sed '1,/BEGIN_EXPORT_UNARY_REALD/d;/END_EXPORT_UNARY_REALD/,$d' lib/operators/types.h |
    awk '{ print "UNOP_REALD(" $1 "," NR + 1000 ")" }' 
    sed '1,/BEGIN_EXPORT_UNARY_VOID/d;/END_EXPORT_UNARY_VOID/,$d' lib/operators/types.h |
    awk '{ print "UNOP_VOID(" $1 "," NR + 2000 ")" }' 
) > lib/operators/register.h

(
    echo "# warning, this file is automatically generated, do not modify!"
    echo "def register(reg,op):"
    sed '1,/BEGIN_EXPORT_UNARY_REALD/d;/END_EXPORT_UNARY_REALD/,$d' lib/operators/types.h |
    awk '{ print "  reg." $1 " = lambda dst, src: op.unary(" NR + 1000 ",dst,src)" }' 
    sed '1,/BEGIN_EXPORT_UNARY_VOID/d;/END_EXPORT_UNARY_VOID/,$d' lib/operators/types.h |
    awk '{ print "  reg." $1 " = lambda dst, src: op.unary(" NR + 2000 ",dst,src)" }' 
) > ../gpt/qcd/fermion/register.py

# Compile
for src in lib/*.cc
do
    bn=$(basename $src .cc)
    dst=build/${bn}.o
    if [ $src -nt $dst ];
    then
	(
	    echo " [CXX] $bn"
	    start=$SECONDS
	    ${CXX} --shared ${CXXFLAGS} -c $src -o $dst 1> logs/${bn}.out 2> logs/${bn}.err
	    success=$?
	    elapsed=$((SECONDS-start))
	    if [[ "$success" == "0" ]];
	    then
		printf "%-50s %s\n" " [OK ] $bn " "($elapsed s)"
	    else
		printf "%-50s %-30s %s\n" " [ERR] $bn " "($elapsed s)" "logs/${bn}.err"
	    fi
	) &
	N=$((N+1))
	if ((N==NPARALLEL))
	then
	    wait
	    N=0
	fi
    fi
done

wait

# Link
OBS="build/gversions.o build/basis.o  build/coordinates.o  build/eval.o build/expression_linear_combination.o build/fp16.o  build/init.o build/mpi.o    build/operators.o  build/time.o  build/util.o
build/block.o  build/distribute.o   build/expression_gammamul.o  build/expression_mul.o build/grid.o  build/io.o    build/lib.o      build/munge.o  build/random.o     build/transform.o"
nvcc --link --shared build/lattice.o ${OBS} ${CXXFLAGS} ${LDFLAGS} ${LIBS} -lGrid -o ../cgpt.so

#nvcc --link --shared build/*.o ${CXXFLAGS} ${LDFLAGS} ${LIBS} -lGrid -o ../cgpt.so
